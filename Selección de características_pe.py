# -*- coding: utf-8 -*-
"""selección de caracteristicas PE.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1P9JaOomiFe3Ca6I1T1yVFM799efRqqU3
"""

import pandas as pd
from sklearn.preprocessing import LabelEncoder
from sklearn.ensemble import RandomForestClassifier
import matplotlib.pyplot as plt
import numpy as np
from sklearn.feature_selection import RFE
from sklearn.decomposition import PCA
from sklearn.preprocessing import StandardScaler
import lightgbm as lgb
from sklearn.model_selection import train_test_split
from sklearn.feature_selection import SelectFromModel

from google.colab import files
uploaded = files.upload()

# Carga tu conjunto de datos
df = pd.read_csv('dataset_malwares.csv')

# Asegúrate de que la columna 'Malware' son las etiquetas
y = df['Malware']

# Prepara tus datos para el aprendizaje automático
# Excluye la primera columna (la de los nombres)
X = df.drop(df.columns[0], axis=1)
X = X.drop('Malware', axis=1)
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

#Entrenal un ligthGBM
lgbm = lgb.LGBMClassifier()
lgbm.fit(X_scaled, y)
importances = lgbm.feature_importances_

#Grafica de importancia
indices = np.argsort(importances)[::-1]
plt.figure(figsize=(15, 10))
plt.title("Importancia de las características")
plt.bar(range(X.shape[1]), importances[indices], color="r", align="center")
plt.xticks(range(X.shape[1]), df.columns[indices], rotation='vertical')
plt.xlim([-1, X.shape[1]])
plt.tight_layout()
plt.show()

# Selección de características
selector = SelectFromModel(lgbm, prefit=True, threshold=-np.inf, max_features=15)
X_selected = selector.transform(X_scaled)
selected_features = X.columns[selector.get_support()]
print("Selected features:", selected_features)

# Entrenamiento del modelo con características seleccionadas
X_train, X_test, y_train, y_test = train_test_split(X_selected, y, test_size=0.2, random_state=42)
lgbm.fit(X_train, y_train)

# Evaluación del modelo
y_pred = lgbm.predict(X_test)
from sklearn.metrics import accuracy_score, confusion_matrix, classification_report
print("Accuracy:", accuracy_score(y_test, y_pred))
print("Confusion Matrix:\n", confusion_matrix(y_test, y_pred))
print("Classification Report:\n", classification_report(y_test, y_pred))

# Entrenando el Ramdom Forest
rf = RandomForestClassifier()
rf.fit(X_scaled, y)
importances = rf.feature_importances_

# Importancia de las características
indices = np.argsort(importances)[::-1]
plt.figure(figsize=(15, 10))
plt.title("Importancia de las características")
plt.bar(range(X.shape[1]), importances[indices], color="r", align="center")
plt.xticks(range(X.shape[1]), X.columns[indices], rotation='vertical')
plt.xlim([-1, X.shape[1]])
plt.tight_layout()
plt.show()

# Selección de características
selector = SelectFromModel(rf, prefit=True, threshold=-np.inf, max_features=15)
X_selected = selector.transform(X_scaled)
selected_features = X.columns[selector.get_support()]
print("Selected features:", selected_features)

# Entrenar con las características
X_train, X_test, y_train, y_test = train_test_split(X_selected, y, test_size=0.2, random_state=42)
rf.fit(X_train, y_train)

# Evaluar el modelo
y_pred = rf.predict(X_test)
from sklearn.metrics import accuracy_score, confusion_matrix, classification_report
print("Accuracy:", accuracy_score(y_test, y_pred))
print("Confusion Matrix:\n", confusion_matrix(y_test, y_pred))
print("Classification Report:\n", classification_report(y_test, y_pred))

featuresRF = ['TimeDateStamp', 'Characteristics', 'MajorLinkerVersion',
       'SizeOfInitializedData', 'ImageBase', 'MajorOperatingSystemVersion',
       'MinorOperatingSystemVersion', 'MajorImageVersion', 'MinorImageVersion',
       'MajorSubsystemVersion', 'MinorSubsystemVersion', 'Subsystem',
       'DllCharacteristics', 'SizeOfStackReserve', 'DirectoryEntryExport', 'Malware']

correlation = df[featuresRF].corrwith(df['Malware'])
print(correlation)

features =['TimeDateStamp', 'Characteristics', 'MajorLinkerVersion', 'SizeOfInitializedData',
                      'AddressOfEntryPoint', 'CheckSum', 'DllCharacteristics', 'SectionMinEntropy',
                      'SectionMaxPhysical', 'SectionMaxChar', 'DirectoryEntryImport', 'DirectoryEntryImportSize',
                      'DirectoryEntryExport', 'ImageDirectoryEntryResource', 'ImageDirectoryEntrySecurity', 'Malware']

correlation = df[features].corrwith(df['Malware'])
print(correlation)

# Asumiendo que 'df' es tu DataFrame original
df_new = df[features]

df_new.to_csv('df_new_15.1.csv', index=False)

# Descarga el archivo CSV
files.download('df_new_15.1.csv')
